---
title: "Advanced Task Manager"
publishDate: "Dec 2024"
description: "A Vite + React + Typescript task manager app with lightweight ai features written to practice complex state management."
project: true
src:
  {
    image:
      {
        path: "/assets/task_manager_screenshot.png",
        alt: "task manager app screenshot",
      },
    video: "",
    scene: false,
    link: "https://priority-task-manager.vercel.app",
  }
technologies:
  - "Typescript"
  - "Tailwind CSS"
  - "Vite"
  - "React"
---

[![Task Manager Site Image](/assets/task_manager_screenshot.png)](https://priority-task-manager.vercel.app)

## Managing Complex State: From useState to useReducer

This guide asummes you have some foundational knowledge of the [useState](https://react.dev/reference/react/useState) hook in React, which is a great entry point in understanding how state is managed in a web app.

However, many real-world applications require more efficient ways of handling the state of an app, and things can get complicated quickly. Consider the state of an e-commerce shopping cart. We'd need to handle the product quanity, various attributes like size and color, manage remove/undo operations, and much more. When state logic becomes this intricate, leveraging React's [useReducer](https://react.dev/reference/react/useReducer) hook can significantly simplify our code and improve its maintainability, as I hope to illustrate soon.

To better understand the functionality of the `useReducer` hook, I decided to build a task manager application and handle the state of tasks with a friendly and modern user interface. I hope this guide can illustrate the power of this hook and provide a good starting point on how to use it.

## useReducer TL;DR

`useReducer` follows a simple pattern: when something happens in your app (an action, which you define and implement anywhere in the app), it goes through a reducer function that knows exactly how to update your state based on that action. The basic syntax is as follows:

```typescript
const [state, dispatch] = useReducer(reducer, initialState);
```

Take note of the reducer argument in the hook, this is a function that receives the **current state** and an **action**, and promptly returns a **new** state based on what that action is trying to do. We'll go over the reducer function's implementation soon.

The dispatch function is how we send actions to the reducer. It sends **declarative** instructions to the reducer that tell it how to update the state. For example:

```typescript
// Instead of setState({ ...state, tasks: [...state.tasks, newTask] })
dispatch({
  type: "ADD_TASK",
  payload: { task: "Learn useReducer", priority: "High" },
});
```

Instead of directly manipulating the state, we describe what we want to happen to the state (and provide an optional payload object), and the reducer handles returning and setting a new state. The reducer takes care of the "how" while our ui components will take care of the "what".

## Initial Design Steps and State Breakdown

Before we dive in to the state of our app, let's begin to visualize how each task item will be structured. First, what information will potential users want to see and modify? The simple answer is the task description and priority level. Cool, now off the top of my head, what are some basic functionality a task manager app will need to have for each task item? Well, completion toggling, a unique identifier for each task item and basic chronological operations sound like a good start. So let's put it all together in the TaskItem interface:

```typescript
export interface TaskItem {
  id: string;
  task: string;
  priority: "Low" | "Medium" | "High";
  completed: boolean;
  createdAt: Date;
}
```

Awesome, let's move on to the overall application state. When thinking about an app's state, it's important to not only consider the task items, but also the UI state that affects how users will be able to interact with them. On an app that displays task items, should we include filtering options, and what should we filter by? What if a user wants to use bulk actions on a selected amount of tasks, where do we store the selected tasks? What about basic error messages? We need to track

- All the task items
- What filters are active
- Any error messages we want to show
- Which tasks are currently selected for bulk actions

This led me to the following TasksState interface:

```typescript
export interface TasksState {
  taskItems: TaskItem[];
  filter: {
    priorities: Array<"Low" | "Medium" | "High">;
    status: "Active" | "Completed" | null;
  };
  errors: {
    task?: string;
    priority?: string;
    prompt?: string;
  };
  selectedTasks: string[];
}
```

The filter object is structured to handle both priority and status filtering options, and the errors object uses optional properties (that's what the `?` is for) to set specific error messages when needed.

Alright. Now it's important to define what actions a user will be able to take on the state of our tasks. Off the top of my head, I can think of plenty. Toggling completion of a task, changing the priority level, deleting a task, marking it as complete, modifying the description, etc. That's just for a single task, what about bulk actions? Bulk deletion, update, marking as complete, and more should also be actions that we define. Therefore, I defined the following TaskAction union type, with appropriate type and payload objects. It is usually good practice to have these defined.

```typescript
export type TaskAction =
  // Individual task operations
  | { type: "ADD_TASK"; payload: Omit<TaskItem, "id" | "createdAt"> }
  | { type: "DELETE_TASK"; payload: string }
  | {
      type: "UPDATE_PRIORITY";
      payload: { id: string; priority: TaskItem["priority"] };
    }
  | { type: "TOGGLE_COMPLETION"; payload: string }
  | { type: "TOGGLE_SELECT"; payload: string }
  // Bulk operations for selected tasks
  | { type: "BULK_DELETE" }
  | { type: "BULK_UPDATE_PRIORITY"; payload: TaskItem["priority"] }
  | { type: "BULK_MARK_AS_COMPLETE" }
  | { type: "BULK_MARK_AS_INCOMPLETE" }
  | { type: "CLEAR_SELECTED" }
  | { type: "TOGGLE_SELECT_ALL" }
  | { type: "CLEAR_COMPLETED" }
  // Error handling
  | { type: "SET_ERROR"; payload: Partial<TasksState["errors"]> }
  | { type: "CLEAR_ERRORS" }
  // Filter management
  | { type: "SET_FILTER"; payload: Partial<TasksState["filter"]> };
```

A couple of notes on typescript features here.

- `Omit<TaskItem, "id" | "createdAt">` tells TypeScript to use TaskItem's type but leave out the id and createdAt fields (since we'll generate those when adding a task)
- `Partial<TasksState["errors"]>` means we can provide some or all of the error fields with this action's payload.
- Using string literal types (like "ADD_TASK") gives the IDE autocompletion features (if supported) whenever we dispatch these actions in our components code.

## Reducer Function Implementation

Let's implement the reducer function. This function was defined in a `reducer.ts` file as follows:

```typescript
export function taskReducer(state: TasksState, action: TaskAction): TasksState {...}
```

As explained before, it receives the current state and an action to take on that state. A concept that is crucial to understand is that this reducer function must be a pure function, meaning it must never modify the existing state but return a new state object. This concept is known as immutability and it tripped me up on a couple of occasions.
